import org.apache.spark.SparkConf;
import org.apache.spark.api.java.JavaPairRDD;
import org.apache.spark.api.java.JavaRDD;
import org.apache.spark.api.java.JavaSparkContext;
import org.apache.spark.api.java.function.Function2;
import org.apache.spark.api.java.function.Function;
import org.apache.spark.api.java.function.PairFlatMapFunction;
import org.apache.spark.api.java.function.PairFunction;
import scala.Serializable;
import scala.Tuple2;

import java.util.ArrayList;
import java.util.Iterator;

/***
 * AssigTwoz5197332
 * Created by z5197332 on 2019/11/15.
 * ----------------------------------------------------------------------------------------------------
 * Purpose:																							  //  
 * Using Spark Core and BFS algorithm to implement a solution for Single-Source Shortest Path problem.//
 * ----------------------------------------------------------------------------------------------------
 * Solution:
 * The first step is to create a PairRDD called step1 table for join purpose. 
 * Each record in table contains start node, the path from the start node and the cost.
 * In order to get all nodes, step1's keys union all end nodes' keys by swapping start and 
 * end nodes in the first step. 
 * 
 * BFS algorithm is used to compute the shortest path to each node. 
 * In BFS, the first step is to generate a start RDD from the start node. 
 * Then using this start RDD to join the step1 table to get next path. 
 * Iteration stops when no vertex's shortest distance requires to change. 
 * In worst case, computation need to take the total number of nodes times iterations.
 * The total number of nodes is calculated by count method.
 * 
 * After generating all graph information, the code selects the shortest distance and reduce by key. 
 * In order to sort by key, the code creates a new RDD to store distance as keys. 
 * 
 * For those nodes without path graph, a without_path_graph RDD was created. 
 * The final graph was generated by using union method to union the graph with path and 
 * the graph without path from the start node. An formatting RDD is created to output the 
 * file by the specified format.
 * 
 * ***/

public class AssigTwoz5197332 {
    public static void main(String[] args) {
        SparkConf conf = new SparkConf()
                .setAppName("Assignment 1")
                .setMaster("local");
        
        String startNode = args[0];
        JavaSparkContext context = new JavaSparkContext(conf);
        JavaRDD<String> input = context.textFile(args[1]); 
        
        //table: for join purpose 
        JavaPairRDD<String, Tuple2<String, Integer>> step1 = input.mapToPair(new PairFunction<String, String, Tuple2<String, Integer>>() {
			@Override
			public Tuple2<String, Tuple2<String, Integer>> call(String line) throws Exception {
				// TODO Auto-generated method stub
				String [] parts = line.split(",");
                String node_start = parts[0];
                String path = node_start + "-" + parts[1];
                Integer distance = Integer.parseInt(parts[2]);
                return new Tuple2<String, Tuple2<String, Integer>>(node_start, new Tuple2<>(path, distance));
			}
        });
        
        //all nodes with path
        JavaRDD<String> nodes_with_path = step1.groupByKey().keys();

        //swap start and end nodes,to get all end nodes' keys        
        JavaPairRDD<String, String> swap_input = step1.mapToPair(new PairFunction<Tuple2<String, Tuple2<String, Integer>>, String, String>() {
			@Override
			public Tuple2<String, String> call(Tuple2<String, Tuple2<String, Integer>> line) throws Exception {
				// TODO Auto-generated method stub
				return new Tuple2<String, String>(line._2._1.split("-")[1],line._1);
			}
			
        });
        
        //all end nodes
        JavaRDD<String> end_nodes = swap_input.groupByKey().keys();

        //union all nodes with path  and end nodes to get all nodes
        JavaRDD<String> all_nodes = end_nodes.union(nodes_with_path); 
        
        //distinct all nodes
        JavaRDD<String> node_list =all_nodes.distinct();

        //number of all nodes
        int count= (int)node_list.count();
        
        JavaPairRDD<String, Tuple2<String, Integer>> start_RDD = step1.flatMapToPair(new PairFlatMapFunction<Tuple2<String, Tuple2<String, Integer>>,String,Tuple2<String, Integer>>() {
			@Override
			public Iterator<Tuple2<String, Tuple2<String, Integer>>> call(
					Tuple2<String, Tuple2<String, Integer>> line) throws Exception {
				// TODO Auto-generated method stub
		        ArrayList<Tuple2<String, Tuple2<String, Integer>>> result = new ArrayList<Tuple2<String, Tuple2<String, Integer>>>();
		        if (line._1.equals(startNode)) {
		        	String neighbour = (line._2)._1.split("-")[1];
		        	String path = line._1 + "-" + neighbour;
		            Integer distance = line._2._2;
		            Tuple2<String, Integer> inside = new Tuple2<String, Integer>(path,distance);
		            result.add(new Tuple2<>(neighbour,inside));
		        }
		        return result.iterator();
			}
        });

        JavaPairRDD<String, Tuple2<String, Integer>> graphs = start_RDD;
        for (int i =0; i < (count-1); i++) {
        	JavaPairRDD<String,Tuple2<Tuple2<String,Integer>,Tuple2<String,Integer>>> combined = start_RDD.join(step1);     
	        JavaPairRDD<String, Tuple2<String, Integer>> first_Path = combined.flatMapToPair(new PairFlatMapFunction<Tuple2<String, Tuple2<Tuple2<String, Integer>, Tuple2<String, Integer>>>,String,Tuple2<String, Integer>>(){
				@Override
				public Iterator<Tuple2<String, Tuple2<String, Integer>>> call(
						Tuple2<String, Tuple2<Tuple2<String, Integer>, Tuple2<String, Integer>>> line) throws Exception {
					// TODO Auto-generated method stub	
					ArrayList<Tuple2<String, Tuple2<String, Integer>>> result = new ArrayList<Tuple2<String, Tuple2<String, Integer>>>();
					//& (line._2._1._1.split("-")[1].indexOf(startNode) == -1)){
					if ((line._2._1._1.indexOf(line._2._2._1.split("-")[1]) == -1)) {
						String node = line._2._2._1.split("-")[1];
						String path = line._2._1._1 + "-"+ node;
						Integer distance = line._2._1._2 + line._2._2._2;
						Tuple2<String, Integer> inside = new Tuple2<String, Integer>(path,distance);
						result.add(new Tuple2<>(node,inside));	
					}
					return result.iterator();
				}
	        });
	        graphs= graphs.union(first_Path);
	        start_RDD = first_Path;
        }
        
        JavaPairRDD<String, Tuple2<String, Integer>> temp_graph = graphs.reduceByKey(new Function2<Tuple2<String, Integer>,Tuple2<String, Integer>, Tuple2<String, Integer>>(){
			@Override
			public Tuple2<String, Integer> call(Tuple2<String, Integer> arg0, Tuple2<String, Integer> arg1)
					throws Exception {
				// TODO Auto-generated method stub
				Tuple2<String, Integer> path_distance;
				if (arg0._2 <  arg1._2) {
					path_distance = new Tuple2<>(arg0._1,arg0._2);
				}else {
					path_distance = new Tuple2<>(arg1._1,arg1._2);
				}
				return path_distance;
			}	
        });

        //have shortest path's nodes
        JavaRDD<String> graph_keys = temp_graph.groupByKey().keys();
        
        //node with no path to the start node
        JavaRDD<String> nodes_with_no_path = node_list.subtract(graph_keys);

        //sort graph by distance
        JavaPairRDD<Integer, Tuple2<String, String>> graph_for_sort = temp_graph.mapToPair(new PairFunction<Tuple2<String, Tuple2<String, Integer>>,Integer,Tuple2<String, String>>(){
			@Override
			public Tuple2<Integer, Tuple2<String, String>> call(Tuple2<String, Tuple2<String, Integer>> line)
					throws Exception {
				// TODO Auto-generated method stub			
				Tuple2<String, String> new_tuple =new Tuple2<>(line._1,line._2._1);
				return new Tuple2<Integer, Tuple2<String, String>>(line._2._2,new_tuple);
			}
        }).sortByKey();
        
        JavaPairRDD<String, Tuple2<Integer, String>> final_graph = graph_for_sort.mapToPair(new PairFunction<Tuple2<Integer, Tuple2<String, String>>,String, Tuple2<Integer, String>>(){
			@Override
			public Tuple2<String, Tuple2<Integer, String>> call(Tuple2<Integer, Tuple2<String, String>> line)
					throws Exception {
				// TODO Auto-generated method stub
				Tuple2<Integer, String> distance_path =new Tuple2<>(line._1,line._2._2);
				return new Tuple2<String, Tuple2<Integer, String>>(line._2._1,distance_path);
			}
        });
        
        //create RDD for nodes without path
        JavaPairRDD<String, Tuple2<Integer, String>> without_path_graph = nodes_with_no_path.flatMapToPair(new PairFlatMapFunction<String, String, Tuple2<Integer, String>>(){
			@Override
			public Iterator<Tuple2<String, Tuple2<Integer, String>>> call(String line) throws Exception {
				// TODO Auto-generated method stub
				ArrayList<Tuple2<String, Tuple2<Integer, String>>> result = new ArrayList<Tuple2<String, Tuple2<Integer, String>>>();
				Integer negative_distance= -1;
				if (!line.equals(startNode)) {
					Tuple2<Integer, String> path_distance;
					path_distance= new Tuple2<>(negative_distance,"");
					result.add(new Tuple2<>(line,path_distance));	
				}
				return result.iterator();
			}
        });
        
        //to generate the whole graph
        JavaPairRDD<String, Tuple2<Integer, String>> graph1 = final_graph.union(without_path_graph);        
        
        JavaRDD<String> output = graph1.map(new Function<Tuple2<String, Tuple2<Integer, String>>,String>(){
			@Override
			public String call(Tuple2<String, Tuple2<Integer, String>> line) throws Exception {
				// TODO Auto-generated method stub
				StringBuilder result = new StringBuilder();
				result.append(line._1).append(',').append(line._2._1).append(',').append(line._2._2);
				return result.toString();
			}
        });
        
        //to save output to file
        output.coalesce(1,true).saveAsTextFile(args[2]); 
    }
}
